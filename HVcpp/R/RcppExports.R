# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Convert an integer to a string of base 
#'
#' @param num INTEGER to be converted
#' @param base INTEGER of base (2,32)
#' @return string of integer in the new base 
NULL

#' Convert an integer to a string of base 
#'
#' @param num INTEGER to be converted
#' @param base INTEGER of base (2,32)
#' @return string of integer in the new base 
s_int2base <- function(num, base = 16L) {
    .Call(`_HVcpp_s_int2base`, num, base)
}

#' Convert an integer to a string of base 
#'
#' @param num INTEGER to be converted
#' @param base INTEGER of base (2,32)
#' @return string of integer in the new base 
cpp_int2base <- function(num, base = 16L) {
    .Call(`_HVcpp_cpp_int2base`, num, base)
}

#' Convert an string of base back to BASE10 INTEGER
#'
#' @param num INTEGER to be converted
#' @param base INTEGER of base (2,32)
#' @return string of integer in the new base 
s_base2int <- function(s, base = 16L) {
    .Call(`_HVcpp_s_base2int`, s, base)
}

#' Convert an string of base back to BASE10 INTEGER
#'
#' @param num INTEGER to be converted
#' @param base INTEGER of base (2,32)
#' @return string of integer in the new base 
cpp_base2int <- function(str, base = 16L) {
    .Call(`_HVcpp_cpp_base2int`, str, base)
}

s_base2base <- function(s, from = 16L, to = 2L) {
    .Call(`_HVcpp_s_base2base`, s, from, to)
}

cpp_base2base <- function(str, from = 16L, to = 2L) {
    .Call(`_HVcpp_cpp_base2base`, str, from, to)
}

s_base64_enc <- function(str) {
    .Call(`_HVcpp_s_base64_enc`, str)
}

cpp_base64_enc <- function(str) {
    .Call(`_HVcpp_cpp_base64_enc`, str)
}

s_base64_dec <- function(str64) {
    .Call(`_HVcpp_s_base64_dec`, str64)
}

cpp_base64_dec <- function(str64) {
    .Call(`_HVcpp_cpp_base64_dec`, str64)
}

say_hello <- function(msg = "hello friend") {
    .Call(`_HVcpp_say_hello`, msg)
}

print_hello <- function(raw) {
    .Call(`_HVcpp_print_hello`, raw)
}

s_SHIFT_R <- function(a, b) {
    .Call(`_HVcpp_s_SHIFT_R`, a, b)
}

#' Shift Bits to the Right
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
cpp_SHIFT_R <- function(arr, b) {
    .Call(`_HVcpp_cpp_SHIFT_R`, arr, b)
}

s_SHIFT_L <- function(a, b) {
    .Call(`_HVcpp_s_SHIFT_L`, a, b)
}

#' Shift Bits to the LEFT
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
cpp_SHIFT_L <- function(arr, b) {
    .Call(`_HVcpp_cpp_SHIFT_L`, arr, b)
}

s_AND <- function(a, b) {
    .Call(`_HVcpp_s_AND`, a, b)
}

#' Pairwise AND operations
#'
#' @param a INTEGER to be manipulated
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after AND
cpp_AND <- function(arr, brr) {
    .Call(`_HVcpp_cpp_AND`, arr, brr)
}

s_OR <- function(a, b) {
    .Call(`_HVcpp_s_OR`, a, b)
}

#' Pairwise OR operations
#'
#' @param a INTEGER to be manipulated
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after OR
cpp_OR <- function(arr, brr) {
    .Call(`_HVcpp_cpp_OR`, arr, brr)
}

s_XOR <- function(a, b) {
    .Call(`_HVcpp_s_XOR`, a, b)
}

#' Pairwise XOR operations
#'
#' @param a INTEGER to be manipulated 
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after XOR
cpp_XOR <- function(arr, brr) {
    .Call(`_HVcpp_cpp_XOR`, arr, brr)
}

s_NOT <- function(a) {
    .Call(`_HVcpp_s_NOT`, a)
}

#' NOT operation
#'
#' @param a INTEGER to be manipulated
#' @return Updated INTEGER after NOT
cpp_NOT <- function(arr) {
    .Call(`_HVcpp_cpp_NOT`, arr)
}

#' Compute gcd / lcm simultaneously (Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return two INTEGER values in list form (gcd) and (lcd)
cpp_gcd_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd_lcm`, x, y)
}

#' Compute gcd	(Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (gcd)
cpp_gcd <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd`, x, y)
}

#' Compute lcd	(Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (lcd)
cpp_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_lcm`, x, y)
}

#' Compute md5 of single element 
#'
#' @param str Single String Element
#' @return single MD5 (times = 1)
s_md5 <- function(str) {
    .Call(`_HVcpp_s_md5`, str)
}

#' Compute md5 of CharacterVector
#'
#' @param str CharacterVector of Strings
#' @param times INTEGER on how many iterations on single string
#' @return CharacterVector of MD5(times)
cpp_md5 <- function(str, times = 1L) {
    .Call(`_HVcpp_cpp_md5`, str, times)
}

#' Get System nanoseconds
#'
#' @return time in nanosecond
cpp_nano <- function() {
    .Call(`_HVcpp_cpp_nano`)
}

#' Get System nanoseconds
#'
#' @return time in nanosecond
cpp_micro <- function() {
    .Call(`_HVcpp_cpp_micro`)
}

#' Get System nanoseconds
#'
#' @return time in nanosecond
cpp_milli <- function() {
    .Call(`_HVcpp_cpp_milli`)
}

#' Get System now based on precision
#'
#' @return time in input 
cpp_now <- function(precision = "nano") {
    .Call(`_HVcpp_cpp_now`, precision)
}

#' Get System time (Similar to Sys.time())
#'
#' @return time in input 
cpp_time <- function() {
    .Call(`_HVcpp_cpp_time`)
}

#' Compute NumericVector of Primes
#'
#' (ported from pracma::primes) with new 'n' primes functionality
#' SLOWS above 10^7
#'
#' @param n How Many
#' @param first BOOLEAN (if FALSE) returns primes <= 'n' ELSE returns 'n' primes
#' @return NumberVector of PRIMES 
cpp_primes <- function(n, first = FALSE) {
    .Call(`_HVcpp_cpp_primes`, n, first)
}

cpp_sort_numeric_works <- function(arr, dir = "ASC") {
    .Call(`_HVcpp_cpp_sort_numeric_works`, arr, dir)
}

cpp_sort_numeric <- function(arr, partial, dir = "ASC") {
    .Call(`_HVcpp_cpp_sort_numeric`, arr, partial, dir)
}

#' Reverse a String s
#'
#' @param String to 'repeat'
#' @return updated String reversed	
s_str_reverse <- function(s) {
    .Call(`_HVcpp_s_str_reverse`, s)
}

#' Reverse a String s
#'
#' @param String to 'repeat'
#' @return updated String reversed	
cpp_str_reverse <- function(str) {
    .Call(`_HVcpp_cpp_str_reverse`, str)
}

#' Repeat a String s
#'
#' @param String to 'repeat'
#' @param Integer 'times' to 'repeat'
#' @return updated String repeated 'times'	
s_str_repeat <- function(s, times) {
    .Call(`_HVcpp_s_str_repeat`, s, times)
}

#' Repeat a String s
#'
#' @param String to 'repeat'
#' @param Integer 'times' to 'repeat'
#' @return updated String repeated 'times'	
cpp_str_repeat <- function(str, times) {
    .Call(`_HVcpp_cpp_str_repeat`, str, times)
}

#' String Right Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, right trimmed
s_rtrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_rtrim`, s, t)
}

#' String Right Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, right trimmed
cpp_rtrim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_rtrim`, str, t)
}

#' String Left Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, left trimmed
s_ltrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_ltrim`, s, t)
}

#' String Left Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, left trimmed
cpp_ltrim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_ltrim`, str, t)
}

#' String BothTrim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
s_btrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_btrim`, s, t)
}

#' String Both Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
cpp_btrim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_btrim`, str, t)
}

#' String Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
s_trim <- function(s, side = "both", t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_trim`, s, side, t)
}

#' String  Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
cpp_trim <- function(str, side = "both", t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_trim`, str, side, t)
}

#' String to lower case
#'
#' @param s String to be transformed
#' @return Updated String s, lower cased
s_tolower <- function(s, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_s_tolower`, s, locale)
}

#' String to lower case
#'
#' @param s String to be transformed
#' @return Updated String s, lower cased
cpp_strtolower <- function(str, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_cpp_strtolower`, str, locale)
}

#' String to upper case
#'
#' @param s String to be transformed
#' @return Updated String s, upper cased
s_toupper <- function(s, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_s_toupper`, s, locale)
}

#' String to upper case
#'
#' @param s String to be transformed
#' @return Updated String s, upper cased
cpp_strtoupper <- function(str, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_cpp_strtoupper`, str, locale)
}

#' Get String Length
#'
#' @param s String to be sized
#' @return integer length
s_strlen <- function(s) {
    .Call(`_HVcpp_s_strlen`, s)
}

#' Get String Length
#'
#' @param s String to be sized
#' @return integer length
cpp_strlen <- function(str) {
    .Call(`_HVcpp_cpp_strlen`, str)
}

#' Explode string into array based on separator
#'
#' @param sep String to determine how split
#' @param str String to be exploded (split)
#' @return vector of strings (List array as CharacterVector)
s_explode <- function(sep, s) {
    .Call(`_HVcpp_s_explode`, sep, s)
}

#' Explode string into array based on separator
#'
#' @param sep String to determine how split
#' @param str String to be exploded (split)
#' @return vector of strings (List array as CharacterVector)
cpp_explode <- function(sep, str) {
    .Call(`_HVcpp_cpp_explode`, sep, str)
}

#' Implode string array into string based on separator
#'
#' @param vector of strings (array as CharacterVector)
#' @param sep String to determine how join
#' @return joined String
s_implode <- function(sep, r) {
    .Call(`_HVcpp_s_implode`, sep, r)
}

#' Implode string array into string based on separator
#'
#' @param vector of strings (array as CharacterVector)
#' @param sep String to determine how join
#' @return joined String
cpp_implode <- function(sep, str) {
    .Call(`_HVcpp_cpp_implode`, sep, str)
}

#' Search/Replace a String Subject
#'
#' @param String to 'search'
#' @param String to 'replace'
#' @param String 'subject'
#' @return updated 'subject' String appropriate replaced ... (no REGEX here)
s_str_replace <- function(search, replace, subject) {
    .Call(`_HVcpp_s_str_replace`, search, replace, subject)
}

#' Search/Replace a String Subject
#'
#' @param String to 'search'
#' @param String to 'replace'
#' @param String 'subject'
#' @return updated 'subject' String appropriate replaced ... (no REGEX here)
cpp_str_replace <- function(search, replace, subject) {
    .Call(`_HVcpp_cpp_str_replace`, search, replace, subject)
}

s_uuid_basic <- function() {
    .Call(`_HVcpp_s_uuid_basic`)
}

cpp_uuid_basic <- function(n = 5L) {
    .Call(`_HVcpp_cpp_uuid_basic`, n)
}

s_uuid_basic_v4 <- function() {
    .Call(`_HVcpp_s_uuid_basic_v4`)
}

cpp_uuid_basic_v4 <- function(n = 5L) {
    .Call(`_HVcpp_cpp_uuid_basic_v4`, n)
}

