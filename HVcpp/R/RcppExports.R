# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Shift Bits to the Right
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
bits_RShift <- function(arr, b) {
    .Call(`_HVcpp_bits_RShift`, arr, b)
}

#' Shift Bits to the LEFT
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
bits_LShift <- function(arr, b) {
    .Call(`_HVcpp_bits_LShift`, arr, b)
}

#' Pairwise AND operations
#'
#' @param a INTEGER to be manipulated
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after AND
bits_AND <- function(arr, brr) {
    .Call(`_HVcpp_bits_AND`, arr, brr)
}

#' Pairwise OR operations
#'
#' @param a INTEGER to be manipulated
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after OR
bits_OR <- function(arr, brr) {
    .Call(`_HVcpp_bits_OR`, arr, brr)
}

#' Pairwise XOR operations
#'
#' @param a INTEGER to be manipulated
#' @param b INTEGER to be manipulated
#' @return Updated INTEGER after XOR
bits_XOR <- function(arr, brr) {
    .Call(`_HVcpp_bits_XOR`, arr, brr)
}

#' NOT operation
#'
#' @param a INTEGER to be manipulated
#' @return Updated INTEGER after NOT
bits_NOT <- function(arr) {
    .Call(`_HVcpp_bits_NOT`, arr)
}

#' Compute gcd / lcm simultaneously (Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return two INTEGER values in list form (gcd) and (lcd)
cpp_gcd_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd_lcm`, x, y)
}

#' Compute gcd	(Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (gcd)
cpp_gcd <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd`, x, y)
}

#' Compute lcd	(Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (lcd)
cpp_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_lcm`, x, y)
}

#' Compute md5 of CharacterVector
#'
#' @param str CharacterVector of Strings
#' @param times INTEGER on how many iterations on single string
#' @return CharacterVector of MD5(times)
cpp_md5 <- function(str, times = 1L) {
    .Call(`_HVcpp_cpp_md5`, str, times)
}

#' Compute NumericVector of Primes
#'
#' (ported from pracma::primes) with new 'n' primes functionality
#' SLOWS above 10^7
#'
#' @param n How Many
#' @param first BOOLEAN (if FALSE) returns primes <= 'n' ELSE returns 'n' primes
#' @return NumberVector of PRIMES 
cpp_primes <- function(n, first = FALSE) {
    .Call(`_HVcpp_cpp_primes`, n, first)
}

cpp_sort_numeric_works <- function(arr, dir = "ASC") {
    .Call(`_HVcpp_cpp_sort_numeric_works`, arr, dir)
}

cpp_sort_numeric <- function(arr, partial, dir = "ASC") {
    .Call(`_HVcpp_cpp_sort_numeric`, arr, partial, dir)
}

#' Repeat a String s
#'
#' @param String to 'repeat'
#' @param Integer 'times' to 'repeat'
#' @return updated String repeated 'times'	
s_str_repeat <- function(s, times) {
    .Call(`_HVcpp_s_str_repeat`, s, times)
}

#' Repeat a String s
#'
#' @param String to 'repeat'
#' @param Integer 'times' to 'repeat'
#' @return updated String repeated 'times'	
cpp_str_repeat <- function(str, times) {
    .Call(`_HVcpp_cpp_str_repeat`, str, times)
}

#' String Right Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, right trimmed
s_rtrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_rtrim`, s, t)
}

#' String Right Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, right trimmed
cpp_rtrim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_rtrim`, str, t)
}

#' String Left Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, left trimmed
s_ltrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_ltrim`, s, t)
}

#' String Left Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, left trimmed
cpp_ltrim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_ltrim`, str, t)
}

#' String Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
s_trim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_s_trim`, s, t)
}

#' String Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
cpp_trim <- function(str, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_trim`, str, t)
}

#' String to lower case
#'
#' @param s String to be transformed
#' @return Updated String s, lower cased
s_tolower <- function(s, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_s_tolower`, s, locale)
}

#' String to lower case
#'
#' @param s String to be transformed
#' @return Updated String s, lower cased
cpp_strtolower <- function(str, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_cpp_strtolower`, str, locale)
}

#' String to upper case
#'
#' @param s String to be transformed
#' @return Updated String s, upper cased
s_toupper <- function(s, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_s_toupper`, s, locale)
}

#' String to upper case
#'
#' @param s String to be transformed
#' @return Updated String s, upper cased
cpp_strtoupper <- function(str, locale = "en_US.UTF-8") {
    .Call(`_HVcpp_cpp_strtoupper`, str, locale)
}

#' Get String Length
#'
#' @param s String to be sized
#' @return integer length
s_strlen <- function(s) {
    .Call(`_HVcpp_s_strlen`, s)
}

#' Get String Length
#'
#' @param s String to be sized
#' @return integer length
cpp_strlen <- function(str) {
    .Call(`_HVcpp_cpp_strlen`, str)
}

#' Explode string into array based on separator
#'
#' @param sep String to determine how split
#' @param str String to be exploded (split)
#' @return vector of strings (List array as CharacterVector)
s_explode <- function(sep, s) {
    .Call(`_HVcpp_s_explode`, sep, s)
}

#' Explode string into array based on separator
#'
#' @param sep String to determine how split
#' @param str String to be exploded (split)
#' @return vector of strings (List array as CharacterVector)
cpp_explode <- function(sep, str) {
    .Call(`_HVcpp_cpp_explode`, sep, str)
}

#' Implode string array into string based on separator
#'
#' @param vector of strings (array as CharacterVector)
#' @param sep String to determine how join
#' @return joined String
s_implode <- function(sep, r) {
    .Call(`_HVcpp_s_implode`, sep, r)
}

#' Implode string array into string based on separator
#'
#' @param vector of strings (array as CharacterVector)
#' @param sep String to determine how join
#' @return joined String
cpp_implode <- function(sep, str) {
    .Call(`_HVcpp_cpp_implode`, sep, str)
}

#' Search/Replace a String Subject
#'
#' @param String to 'search'
#' @param String to 'replace'
#' @param String 'subject'
#' @return updated 'subject' String appropriate replaced ... (no REGEX here)
s_str_replace <- function(search, replace, subject) {
    .Call(`_HVcpp_s_str_replace`, search, replace, subject)
}

#' Search/Replace a String Subject
#'
#' @param String to 'search'
#' @param String to 'replace'
#' @param String 'subject'
#' @return updated 'subject' String appropriate replaced ... (no REGEX here)
cpp_str_replace <- function(search, replace, subject) {
    .Call(`_HVcpp_cpp_str_replace`, search, replace, subject)
}

