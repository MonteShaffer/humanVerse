# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Shift Bits to the LEFT
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
NULL

#' Shift Bits to the Right
#'
#' @param a INTEGER to be manipulated
#' @param b int to shift
#' @return Updated INTEGER a appropriately shifted
cpp_RShift <- function(a, b) {
    .Call(`_HVcpp_cpp_RShift`, a, b)
}

#' Compute gcd / lcm simultaneously (Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return two INTEGER values in list form (gcd) and (lcd)
cpp_gcd_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd_lcm`, x, y)
}

#' Compute gcd  (Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (gcd)
cpp_gcd <- function(x, y) {
    .Call(`_HVcpp_cpp_gcd`, x, y)
}

#' Compute lcd  (Euler Method)
#'
#' @param x first integer
#' @param y second integer
#' @return INTEGER (lcd)
cpp_lcm <- function(x, y) {
    .Call(`_HVcpp_cpp_lcm`, x, y)
}

#' Compute md5 of CharacterVector
#'
#' @param str CharacterVector of Strings
#' @param times INTEGER on how many iterations on single string
#' @return CharacterVector of MD5(times)
cpp_md5 <- function(str, times = 1L) {
    .Call(`_HVcpp_cpp_md5`, str, times)
}

#' Compute NumericVector of Primes
#'
#' (ported from pracma::primes) with new 'n' primes functionality
#' SLOWS above 10^7
#'
#' @param n How Many
#' @param first BOOLEAN (if FALSE) returns primes <= 'n' ELSE returns 'n' primes
#' @return NumberVector of PRIMES 
cpp_primes <- function(n, first = FALSE) {
    .Call(`_HVcpp_cpp_primes`, n, first)
}

#' Explode string into array based on separator
#'
#' @param s String to be exploded (split)
#' @param sep String to determine how split
#' @return vector of strings (array as CharacterVector)
NULL

#' String Right Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, right trimmed
cpp_rtrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_rtrim`, s, t)
}

#' String Left Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, left trimmed
cpp_ltrim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_ltrim`, s, t)
}

#' String Trim
#'
#' @param s String to be trimmed
#' @param t Trimming elements
#' @return Updated String s, trimmed (both left and right)
cpp_trim <- function(s, t = " \t\n\r\f\v") {
    .Call(`_HVcpp_cpp_trim`, s, t)
}

#' String to lower case
#'
#' @param s String to be transformed
#' @return Updated String s, lower cased
cpp_tolower <- function(s) {
    .Call(`_HVcpp_cpp_tolower`, s)
}

#' String to upper case
#'
#' @param s String to be transformed
#' @return Updated String s, upper cased
cpp_toupper <- function(s) {
    .Call(`_HVcpp_cpp_toupper`, s)
}

#' Get String Length
#'
#' @param s String to be sized
#' @return integer length
cpp_strlen <- function(s) {
    .Call(`_HVcpp_cpp_strlen`, s)
}

#' Implode string array into string based on separator
#'
#' @param vector of strings (array as CharacterVector)
#' @param sep String to determine how join
#' @return joined String
cpp_implode <- function(r, sep = "") {
    .Call(`_HVcpp_cpp_implode`, r, sep)
}

#' Search/Replace a String Subject
#'
#' @param String to 'search'
#' @param String to 'replace'
#' @param String 'subject'
#' @return updated 'subject' String appropriate replaced ... (no REGEX here)
cpp_str_replace <- function(search, replace, subject) {
    .Call(`_HVcpp_cpp_str_replace`, search, replace, subject)
}

#' Repeat a String s
#'
#' @param String to 'repeat'
#' @param Integer 'times' to 'repeat'
#' @return updated String repeated 'times'	
cpp_str_repeat <- function(s, times) {
    .Call(`_HVcpp_cpp_str_repeat`, s, times)
}

