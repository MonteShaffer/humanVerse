% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions-encryption.R, R/functions-md5.R
\name{md5.digest}
\alias{md5.digest}
\title{md5.digest}
\usage{
md5.digest(strvec, times = 1, serialize = FALSE)

md5.digest(strvec, times = 1, serialize = FALSE)
}
\arguments{
\item{strvec}{a character vector of strings}

\item{times}{how many times `n` you want to perform the md5(str)}

\item{serialize}{a parameter passed to the function digest()}
}
\value{
a character vector of equal length, with md5 hashes of each string in original vector

a character vector of equal length, with md5 hashes of each string in original vector
}
\description{
md5.digest

md5.digest
}
\examples{
md5.digest("password");
  # the encryption is one-way, yet a dictionary can "hack"
  # See <https://crackstation.net/> for an example Rainbow Table
  # The best modern tool I have found is SJCL <https://github.com/bitwiseshiftleft/sjcl>
md5.digest("password", times=9); # this will make the Rainbow Table work
  # if you know the original value and the times=n offset, you could build an internal Rainbow Table

md5.digest("The quick brown fox jumps over the lazy dog");
md5.digest( unlist( base::strsplit("The quick brown fox jumps over the lazy dog", " ", fixed=TRUE) ) );

md5.digest("monte.shaffer@gmail.com", 9);
md5.digest("password");
  # the encryption is one-way, yet a dictionary can "hack"
  # See <https://crackstation.net/> for an example Rainbow Table
  # The best modern tool I have found is SJCL <https://github.com/bitwiseshiftleft/sjcl>
md5.digest("password", times=9); # this will make the Rainbow Table work
  # if you know the original value and the times=n offset, you could build an internal Rainbow Table

md5.digest("The quick brown fox jumps over the lazy dog");
md5.digest( unlist( base::strsplit("The quick brown fox jumps over the lazy dog", " ", fixed=TRUE) ) );

md5.digest("monte.shaffer@gmail.com", 9);
}
