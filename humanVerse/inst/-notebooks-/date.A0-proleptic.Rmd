
# fR = forwardRUTHVEN; bR = backwardRUTHVEN;
file.fR = date.generateProleptic(9999); 
file.bR = date.generateProleptic(9999, "BACKWARDS"); 

df.fR = utils::read.csv(file.fR, header=TRUE, quote="", sep="|");
df.bR = utils::read.csv(file.bR, header=TRUE, quote="", sep="|");

range(df.fR$YYYY);
range(df.bR$YYYY);

LOWER = 1575;  # we looped on days = 9999
UPPER = 1625;  # let's truncate the date to have nice START/END in RANGE


df.bRn = subset(df.bR, YYYY >= LOWER); head(df.bRn); tail(df.bRn);
df.fRn = subset(df.fR, YYYY <= UPPER); head(df.fRn); tail(df.fRn);

df.bfRn = rbind(df.bRn, df.fRn);  dim(df.bfRn);
# df.sortBy() may be easier ... 
df.bfRns = df.bfRn[with(df.bfRn, order(-YYYY, -MM, -DD)), ];
	rownames(xdf.sorted) = 1:dim(xdf.sorted)[1];
	head(df.bfRns); tail(df.bfRns);  

# MY DUPLICATE is just one element, has the same IDX of 0
# df = df.bfRns[!duplicated(df.bfRns), ]; # or unique()  # SLOW on large datasets, WHY?
idxs = which(df.bfRns$IDX == 0);
# df.removeRows() may be easier ... 
df = df.bfRns[-c(idxs[1]), ]; dim(df);

df.printHead(df, 8, 1);
df.printHead(df, 8, 999999999);

search = which( df$YYYY == 1600 & df$MM == 8 & df$DD == 5 );
df.printHead(df, 8, search[1]);  # should only have one, JIK

# string subtraction on filenames 
# save to TXT and RDS


# do proleptic number checks ... this was JULIAN PROLEPTIC

df$JPN = as.integer( date.toJulianProlepticNumber(df$YYYY, df$MM, df$DD) );

res = date.fromJulianProlepticNumber(df$JPN);
df$jyear = res$jyear;  		# how to make this happen as a function 
df$jmonth = res$jmonth;		# names unique in df, or append .1 
df$jday = res$jday; 		# check lengths, return NULL on mismatch

# identical ?
idxs = which( (df$YYYY != df$jyear) & (df$MM != df$jmonth) & (df$DD != df$jday) );

## debugging
df$diff = df$DD - df$jday;
search = which(df$diff > 0);
df.printHead(df, 8, search[1]);
## current code has error in FEB 29th ...



